1. 동시성 문제 사례 설명

우리 팀의 웹 애플리케이션은 여러 사용자가 동시에 접속해서 식단을 기록하고,
냉장고(PANTRY_ITEM 테이블)에 있는 재료를 추가/삭제/소비할 수 있다.
특히 냉장고 재료 수량(quantity)을 차감하는 기능은 동시성 문제가 발생하기 쉽다.

예를 들어 같은 계정으로 두 브라우저(혹은 두 탭)에서 동시에 로그인한 뒤,
같은 재료에 대해 "20g씩 소비" 요청을 거의 동시에 보내는 상황을 생각해 볼 수 있다.

동시성 제어를 적용하지 않으면 다음과 같은 순서로 문제가 발생할 수 있다.

(1) 트랜잭션 A가 PANTRY_ITEM에서 현재 수량(quantity)을 50으로 읽는다.
(2) 트랜잭션 B도 동시에 같은 행의 수량을 50으로 읽는다.
(3) A는 20을 빼서 새로운 수량 30으로 UPDATE 한다.
(4) B도 20을 빼서 새로운 수량 30으로 UPDATE 한다.

논리적으로는 20 + 20 = 40이 빠져서 최종 수량이 10이 되어야 하지만,
실제로는 두 번의 UPDATE 결과가 서로 덮어써져서 "잃어버린 갱신(lost update)"이 발생한다.
또한 잘못 구현된 경우 수량이 0 아래로 떨어지는 음수 재고가 저장될 수도 있다.

이와 같은 문제를 해결하기 위해, 우리는 트랜잭션과 행 잠금을 이용한 동시성 제어를 구현하였다.


2. 동시성 제어를 적용한 범위

동시성 제어는 "냉장고 재료 소비" 기능에 적용하였다.
해당 기능은 특정 사용자의 냉장고에서 선택한 재료(item_no)를
지정한 수량만큼 차감하고, 차감 후 수량이 0이 되면 레코드를 삭제한다.

구현 위치는 다음과 같다.

- DAO 클래스: com.team18.dao.PantryDAO
- 메서드 이름: public boolean consumeItem(String userId, int itemNo, double amount)

이 메서드는 하나의 트랜잭션 안에서 수량 조회, 조건 검사, UPDATE/DELETE를 모두 수행하며,
중간에 예외가 발생하거나 수량이 부족하면 전체 작업을 롤백한다.


3. 트랜잭션과 행 잠금 구현 방법

3-1) 트랜잭션 시작

PantryDAO.consumeItem 메서드에서는 다음과 같이 오토 커밋을 끄고 트랜잭션을 시작한다.

    conn = DBUtil.getConnection();
    conn.setAutoCommit(false);

이 이후에 실행되는 SELECT, UPDATE, DELETE는 모두 하나의 트랜잭션 안에서 처리된다.
메서드 마지막에서 문제가 없을 경우 conn.commit()을 호출하고,
예외가 발생하면 conn.rollback()을 호출하여 이전 상태로 되돌린다.

3-2) SELECT ... FOR UPDATE 를 통한 행 잠금

현재 수량을 조회할 때는 단순 SELECT가 아니라 다음과 같이
"FOR UPDATE" 옵션을 사용하여 해당 행을 잠근다.

    SELECT quantity
    FROM PANTRY_ITEM
    WHERE item_no = ? AND user_id = ?
    FOR UPDATE

이 쿼리는 오라클 데이터베이스에서 해당 행에 대해 배타 잠금(row-level exclusive lock)을 건다.
따라서 한 트랜잭션이 이 행을 SELECT FOR UPDATE로 잡고 있는 동안,
다른 트랜잭션은 같은 행을 업데이트하거나 동일한 FOR UPDATE를 시도할 때
대기 상태가 되며, 두 트랜잭션이 동시에 같은 수량을 바탕으로 연산을 수행할 수 없다.

3-3) 수량 검사 및 UPDATE/DELETE

잠금이 걸린 상태에서 현재 수량(currentQty)을 구한 뒤,
차감 후 수량 newQty = currentQty - amount 를 계산한다.

- newQty < 0 인 경우:
  재고보다 더 많은 수량을 소비하려는 시도이므로 비정상적인 요청으로 판단하고
  conn.rollback()을 호출하여 전체 트랜잭션을 롤백한다.

- newQty == 0 인 경우:
  수량이 정확히 0이 되므로 해당 재료를 더 이상 보유하지 않는다고 보고,
  다음과 같이 DELETE를 수행한다.

    DELETE FROM PANTRY_ITEM
    WHERE item_no = ? AND user_id = ?

- newQty > 0 인 경우:
  아직 재고가 남아 있으므로 UPDATE를 통해 수량만 갱신한다.

    UPDATE PANTRY_ITEM
    SET quantity = ?
    WHERE item_no = ? AND user_id = ?

모든 작업이 정상적으로 끝났을 때 conn.commit()을 호출하여 변경 내용을 확정한다.
만약 중간에 예외가 발생하면 catch 블록에서 conn.rollback()을 호출하여
데이터베이스의 일관성을 유지한다.


4. 동시성 제어 적용 후 기대 효과

위와 같이 트랜잭션과 SELECT ... FOR UPDATE를 사용하면 다음과 같은 효과를 얻을 수 있다.

- 동일한 재료 행에 대해 동시에 수량을 차감하려는 요청이 들어와도
  한 번에 하나의 트랜잭션만 수량을 읽고 갱신할 수 있으므로,
  잃어버린 갱신(lost update) 문제가 발생하지 않는다.

- 수량이 0 아래로 떨어지는 것을 사전에 검사하여 롤백하기 때문에,
  데이터베이스에 음수 재고가 저장되는 비일관성(inconsistency)을 방지할 수 있다.

- 수량이 정확히 0이 되는 경우 해당 레코드를 삭제하여,
  "수량 0인 재료가 목록에 남아 있는" 무결성 오류도 함께 예방할 수 있다.

이와 같이, Team18은 냉장고 재고 차감 기능에 대해 트랜잭션과 행 잠금을 적용하여
여러 사용자가 동시에 접근하더라도 데이터베이스의 일관성과 무결성을 유지하도록 구현하였다.
